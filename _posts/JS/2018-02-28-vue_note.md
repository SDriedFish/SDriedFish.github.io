---
layout: post
title: Vue笔记
categories: JS
tags: JS
keywords: Vue笔记
date: 2018-02-18 
---
# 1.简介
## 1.1 What
Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的[渐进式框架][1]。与其它大型框架不同的是，Vue 被设计为可以**自底向上**逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。Vue.js 的目标是通过尽可能简单的 API实现响应的**数据绑定**和组合的**视图组件**。

## 1.2 Why

## 1.2 How
Vuejs的作者尤雨溪写过一篇关于新手学习vue路径的文章[Vue 2.0 的建议学习顺序][2]
## 1.3 特点
![Vue特点]({{site.baseurl}}/assets/img/JS/Vue/feature.png)

1. 简洁：官方文档很清晰，代码编写风格更加简洁，并且通俗易懂。
2. 高效：异步批处理方式更新DOM[^1]和超快虚拟 DOM。
3. 组件化：用解耦的、可复用的组件组合你的应用程序。Vue通过将页面上某一组件的html、CSS、js代码放入一个.vue的文件中进行管理可以大大提高代码的维护性。
4. 轻量：20kB min+gzip 运行大小
5. 数据驱动：是一个MVVM的前端框架

## 1.4 MVVM模式
ViewModel是Vue.js的核心，它是一个Vue实例。Vue实例是作用于某一个HTML元素上的，这个元素可以是HTML的body元素，也可以是指定了id的某个元素。

```html
<div id="app">
  <input v-model="message">
  <p>消息是: {{ message }}</p>
</div>
<script>
new Vue({
  el: '#app',
  data: {
    message: 'hello world'
  }
});
</script>
```

![Vue模型]({{site.baseurl}}/assets/img/JS/Vue/mvvm.png)
首先，我们将上图中的DOM Listeners和Data Bindings看作两个工具，它们是实现双向绑定的关键。

1. 从View侧看，ViewModel中的DOM Listeners工具会帮我们监测页面上DOM元素的变化，如果有变化，则更改Model中的数据；
2. 从Model侧看，当我们更新Model中的数据时，Data Bindings工具会帮我们更新页面中的DOM元素。

# 2.语法

## VUE实例
每个 Vue 应用程序都是通过 Vue 函数创建出一个新的 Vue 实例开始的：
### 创建一个 Vue 实例
```javascript
var vm = new Vue({
  // 选项
})
```
### data
Vue实例的数据都保存在data对象中，Vue将会递归将data的属性转换为getter/setter, 让data数据能够响应变化。
```javascript
// data 对象
var data = { a: 1 }

// 此对象将会添加到 Vue 实例上
var vm = new Vue({
  data: data
})

// 这里引用了同一个对象！
vm.a === data.a // => true

// 设置实例上的属性，也会影响原始数据
vm.a = 2
data.a // => 2
```
如果实例已经创建，那么只有那些 data 中的原本就已经存在的属性，才是响应式的。也就是说，如果在实例创建之后，添加一个新的属性，```vm.b = 'hi'```例如：然后，修改 b 不会触发任何视图更新。

### computed

![生命周期示意图]({{site.baseurl}}/assets/img/JS/Vue/lifecycle.png)

## 2.1 指令
Vue.js的指令是以v-开头的，它们作用于HTML元素，指令提供了一些特殊的特性，将指令绑定在元素上时，指令会为绑定的目标元素添加一些特殊的行为，我们可以将指令看作特殊的HTML特性（attribute）。
Vue.js提供了一些常用的内置指令，接下来我们将介绍以下几个内置指令：

* v-if/v-else/ v-else-if
* v-show指令
* v-for指令
* v-bind指令
* v-on指令

### v-if指令
v-if是条件渲染指令，它根据表达式的真假来删除和插入元素
语法```v-if="expression"```

```html
<div id="app">
    <h1 v-if="yes">Yes!</h1>
    <h1 v-if="age >= 25">Age: {{ age }}</h1>
</div>
<script>
var vm = new Vue({
    el: '#app',
    data: {
        yes: true,
        age: 28
    }
})
</script>
```

如果想切换多个元素呢？此时可以把一个```<template>```元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染
结果将不包含 ```<template>```元素。

```html
<template v-if="ok">
  <h1>Title</h1>
  <p>Paragraph 1</p>
  <p>Paragraph 2</p>
</template>
```

### v-else与v-else-if
v-else，v-else-if必须紧跟在带 v-if或者 v-else-if 的元素之后，分别来表示 v-if 的“else 块”和 的“else-if块”
```html
<div v-if="type === 'A'">A</div>
<div v-else-if="type === 'B'">B</div>
<div v-else>  Not A/B</div>
```
### v-show指令
v-show也是条件渲染指令，和v-if指令不同的是，使用v-show指令的元素始终会被渲染到HTML，它只是简单地为元素设置CSS的style属性。
例子```<h1 v-show="isShow">Hello!</h1>```

### v-for指令
v-for指令基于一个数组渲染一个列表，它和JavaScript的遍历语法相似;v-for指令需要使用```item in items``` 形式的特殊语法，items是源数据数组并且item是数组元素迭代的别名。
```html
<ul id="app">
    <li v-for="(item, index) in items">
        {{ parentMessage }} - {{ index }} - {{ item.message }}
    </li>
</ul>
<script>
var vm = new Vue({
    el: '#app',
    data: {
        parentMessage: 'Parent',
        items: [
            { message: 'Foo' },
            { message: 'Bar' }
        ]
    }
})
</script>
```

### v-bind指令
v-bind指令可以在其名称后面带一个参数，中间放一个冒号隔开，这个参数通常是HTML元素的特性（attribute），例如：v-bind:class
v-bind:argument="expression" 也可以缩写为:argument="expression"
```html
<div id="app">
    <img v-bind:src="url" :title="message" :class="[classA,classB]"/>
</div>
<script>
var vm = new Vue({
    el: '#app',
    data:{
        url: "../img/pg.png",
        title: "this is a Pic",
        classA: 'textColor',
        classB: 'textSize'
    }
})
</script>
```

### v-on指令
v-on指令用于给监听DOM事件，它的用语法和v-bind是类似的，例如监听a元素的点击事件：```<a v-on:click="doSomething">```有两种形式调用方法：绑定一个方法（让事件指向方法的引用），或者使用内联语句。v-on:click也可以缩写为@click="expression"

```html
<div id="app">
    <button v-on:click="counter += 1">Add 1</button>
    <p>The button above has been clicked {{ counter }} times.</p>
    <button v-on:click="say('Hi')">Hi</button>
</div>
<script>
var vm = new Vue({
    el: '#app',
    methods: {
        say: function(msg) {
            alert(msg);
        }
    },
    data: {
        counter: 0,
    }
});
</script>
```

### 自定义指令
Vue除了核心指令外也允许注册自定义指令，语法Vue.directive('directiveName', {[钩子函数][3]})

```html
<div id="app">
    <p>页面载入时，input 元素自动获取焦点：</p>
    <input v-focus>
</div> 
<script>
// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    el.focus();
  }
})
new Vue({
  el: '#app'
})
</script>
```

## 3.组件
组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树：
![components]({{site.baseurl}}/assets/img/JS/Vue/components.png)
那么什么是组件呢？
组件是Vue.js最强大的功能之一。组件可以扩展HTML元素，封装可重用的代码。在较高层面上，组件是自定义的元素，Vue.js的编译器为它添加特殊功能。在有些情况下，组件也可以是原生HTML元素的形式，以is特性扩展。
### 基本步骤
Vue.js的组件的使用有3个步骤：创建组件构造器、注册组件和使用组件。
![components]({{site.baseurl}}/assets/img/JS/Vue/use_component.png)
```html
<div id="app">
    <!-- 3. #app是Vue实例挂载的元素，应该在挂载元素范围内使用组件-->
    <my-component></my-component>
</div>
<script>
// 1.创建一个组件构造器
var myComponent = Vue.extend({
    template: '<div>This is my first component!</div>'
});

// 2.注册组件，并指定组件的标签，组件的HTML标签为<my-component>
Vue.component('my-component', myComponent);

// 3. 实例化组件
new Vue({
    el: '#app'
});
</script>
```
**批注**
1. Vue.extend() 是Vue构造器的扩展，调用Vue.extend()创建的是一个组件构造器，该构造器有一个选项对象，选项对象的template属性用于定义组件要渲染的html。
2. Vue.component() 是注册组件，创建一个组件实例；需要2个参数，第一个参数是自定义组件的标签，第二个参数是组件的构造器。
3. 组件需要挂载到某个Vue的实例下，否则不生效。

### 全局注册和局部注册
调用```Vue.component()```注册组件时，组件的注册是全局的，这意味着该组件可以在任意Vue示例下使用。
如果不需要全局注册，或者是让组件使用在其它组件内，可以用选项对象的components属性实现局部注册。

```html
<div id="app">
    <!--  my-component只能在#app下使用-->
    <my-component></my-component>
</div>
<div id="app2">
    <!-- 不能使用my-component组件，因为my-component是一个局部组件，它属于#app-->
    <my-component></my-component>
</div>
<script>
new Vue({ el: '#app', components: { 'my-component': myComponent } });
</script>
```

### 父组件和子组件
在一个组件中包含另一个组件，那么另一个组件就是该组件的子组件。



[1]: https://www.zhihu.com/question/51907207
[2]: https://zhuanlan.zhihu.com/p/23134551
[3]: https://cn.vuejs.org/v2/guide/custom-directive.html#钩子函数
[^1]:当大量数据变动时，所有受到影响的watcher会被推送到一个队列中，并且每个watcher只会推进队列一次。这个队列会在进程的下一个tick异步执行。这个机制可以避免同一个数据多次变动产生的多余DOM操作，也可以保证所有的DOM写操作在一起执行，避免DOM读写切换可能导致的layout。

